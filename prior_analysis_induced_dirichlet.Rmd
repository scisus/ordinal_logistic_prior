---
title: "Induced dirichlet priors on cutpoints in an ordinal logistic model"
author: "Susannah Tysor"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

Let's repeat this analysis using an induced dirichlet prior on cutpoints. I'll use the same simulated data as above.

I'll test the same $beta_{rate}$ parameters as above. I'll also vary the anchor parameter in the induced dirichlet prior.

In his example, Betancourt sets the anchor to 0. I don't completely understand how the anchor works, so I'll try 5 and 10 as well and see what happens.

```{r paramsForInducedDirichletModels}

beta_rate <- c(1:3) # rate parameters for exponential prior on beta
anchor <- c(0, 5, 10) # different anchor parameters for induced dirichlet prior

# make a nice dataframe with all combinations params used to simulate data and model params used to try to recover those params

parframe_indir <- merge(simulation_input$pars, y=beta_rate) %>%
    rename(beta_rate=y) %>%
    merge(y=anchor) %>%
    rename(anchor=y) %>%
    mutate(h1 = simulation_input$h[1], h2 = simulation_input$h[2])
parframe_indir$modelid <- 1:nrow(parframe_indir)
    
```

I'm going to fit all three simulated datasets with each of the 3 rate prior parameters on beta and anchor parameters on the cutpoints.

``````{r paramsTableGamma}
knitr::kable(parframe_indir, caption="Model parameterizations used to try to recapture params - induced dirichlet")
```

```{r recapture_parameters}
# format parframe so it works with parLapply better
parlist_indir <- make_parframe_list(parframe_indir)

# run all models, parallelized

# make a cluster using half your cores
no_cores <- parallel::detectCores()/2
cl <- parallel::makeCluster(no_cores)

# export the stuff you need to run on the cluster
parallel::clusterExport(cl, c("fit_indir_model", "parlist_indir", "simdat"))
parallel::clusterEvalQ(cl, c(library(rstan), library(StanHeaders)))

# fit the models
## run each model x times
reps <- 2

for (i in 1:reps) {
  fits_indir <- parallel::parLapply(cl, parlist_indir, function(x) {fit_indir_model(simdatlist = simdat, pars=x, groups=FALSE)})
  saveRDS(fits_indir, file = paste0("induced_dirichlet/indir_runs/run", i, ".rds"))
  rm(fits_indir)
  gc()
}

parallel::stopCluster(cl) #close the cluster

```
```{r}
indir_params <- bind_true_model_pars(indirfits, parlist_indir)
```
```{r modelcheck}
map(indirfits, function(x) {rstan:::throw_sampler_warnings(x)})
```

```{r}
map(indir_params, posterior_differencer) %>%
    map2(.y=indir_params, .f=diffplotter)
```

```{r induced_dirichlet_hpdi}
in50 <- map(indir_params, calc_HPDI, prob=0.5)

in75 <- map(indir_params, calc_HPDI, prob=0.75)

in90 <- map(indir_params, calc_HPDI, prob=0.90)

# recaptured parameters
perform50 <- map_df(in50, bind_rows, .id="modelid") %>%
  dplyr::mutate(modelid=as.integer(modelid)) %>%
  full_join(parframe_indir) 
perform90 <- map_df(in90, bind_rows, .id = "modelid") %>%
  dplyr::mutate(modelid=as.integer(modelid)) %>%
  full_join(parframe_indir)

# proportion recaptured parameters
prop_recaptured50 <- perform50 %>%
  group_by(modelid) %>%
  summarise(all_captured = sum(inint)/n()) %>%
  full_join(parframe_indir) %>%
  arrange(beta, desc(all_captured))

prop_recaptured90 <- perform90 %>%
  group_by(modelid) %>%
  summarise(all_captured = sum(inint)/n()) %>%
  full_join(parframe_indir) %>%
  arrange(beta, desc(all_captured))
```

```{r plot_dirichlet_overall}
ggplot(prop_recaptured50, aes(x=as.factor(anchor), y=as.factor(beta_rate), fill=all_captured)) + 
  geom_tile(colour="white") +
  geom_text(aes(label=paste(anchor, beta_rate, sep=","))) +
  facet_wrap("transition", scales="free") +
  ggtitle("Proportion of parameters recaptured in 50% HPDI") +
  scale_fill_gradient(low="white", high="steelblue")

ggplot(prop_recaptured90, aes(x=as.factor(anchor), y=as.factor(beta_rate), fill=all_captured)) + 
  geom_tile(colour="white") +
  geom_text(aes(label=paste(anchor, beta_rate, sep=","))) +
  facet_wrap("transition", scales="free") +
  ggtitle("Proportion of parameters recaptured in 90% HPDI") +
  scale_fill_gradient(low="white", high="violetred")
```
With a normally distributed covariate, the induced dirichlet really struggles, but is good with uniform. Reducing data points from 500 to 50 reduces quality. Also a weird thing keeps happening where 50% seems to do better in some cases than 90% hpdi, but might be a colour scaling issue.
