---
title: "Induced dirichlet priors on cutpoints in an ordinal logistic model"
author: "Susannah Tysor"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

Let's repeat this analysis using an induced dirichlet prior on cutpoints. I'll use the same simulated data as above.

I'll test the same $beta_{rate}$ parameters as above. I'll also vary the anchor parameter in the induced dirichlet prior.

In his example, Betancourt sets the anchor to 0. I don't completely understand how the anchor works, so I'll try 5 and 10 as well and see what happens.

```{r paramsForInducedDirichletModels}

beta_rate <- c(1:3) # rate parameters for exponential prior on beta
anchor <- c(0, 5, 10) # different anchor parameters for induced dirichlet prior

# make a nice dataframe with all combinations params used to simulate data and model params used to try to recover those params

parframe_indir <- merge(simulation_input$pars, y=beta_rate) %>%
    rename(beta_rate=y) %>%
    merge(y=anchor) %>%
    rename(anchor=y) %>%
    mutate(h1 = simulation_input$h[1], h2 = simulation_input$h[2])
parframe_indir$modelid <- 1:nrow(parframe_indir)
    
```

I'm going to fit all three simulated datasets with each of the 3 rate prior parameters on beta and anchor parameters on the cutpoints.

``````{r paramsTableGamma}
knitr::kable(parframe_indir, caption="Model parameterizations used to try to recapture params - induced dirichlet")
```

```{r recapture_parameters}
# format parframe so it works with parLapply better
parlist_indir <- make_parframe_list(parframe_indir)

# run all models, parallelized

# make a cluster using half your cores
no_cores <- parallel::detectCores()/2
cl <- parallel::makeCluster(no_cores)

# export the stuff you need to run on the cluster
parallel::clusterExport(cl, c("fit_indir_model", "parlist_indir", "simdat"))
parallel::clusterEvalQ(cl, c(library(rstan), library(StanHeaders)))

# fit the models
## run each model x times
reps <- 30

for (i in 1:reps) {
  fits_indir <- parallel::parLapply(cl, parlist_indir, function(x) {fit_indir_model(simdatlist = simdat, pars=x, groups=FALSE)})
  saveRDS(fits_indir, file = paste0("induced_dirichlet/covar_runs/run", i, ".rds"))
  rm(fits_indir)
  gc()
}

parallel::stopCluster(cl) #close the cluster

```

```{r readGammaModels, warning=FALSE, cache=TRUE}

# pull in parameters and info on divergences, etc from saved stanfit objects
# very slow step. consider parallelizing to the extent your ram can handle

extracts_indir <- extract_pars_and_problems(path="induced_dirichlet/covar_runs/", parlist=parlist_indir)
```
### Model check
Do a naive check for model problems - divergences and issues with rhats and neff_ratios.

```{r indirModelCheck}
problems_indir <- extracts_indir$problems %>%
  map_dfr(bind_rows, .id=".id") %>%
  rename(run=.id) %>%
  group_by(modelid) %>%
  summarize(bad_proportion = n()/reps, bad_count = n(), divergences_mean=mean(divergences), bad_rhats_mean=mean(bad_rhats), bad_neff_mean=mean(bad_neff))
  
knitr::kable(problems_indir, caption = "Models with divergences, rhats > 1, or neff_ratios < 0.1 - induced dirichlet")

```

15/27 models had problems with Rhat or neff_ratio in 1-6 of the model runs. Only model 4 had neff_ratio problems.

```{r indirExtract}

# extract parameters from stan objects and pair with true param values
params_indir <- extracts_indir$pars %>%
  map_dfr(bind_rows, .id = ".id") %>%
  rename(run=.id) %>%
  split(.$modelid)

```

### Recapture

Of the 5 parameters ($\beta$, $c$ and derived $h$), how many are recaptured by the model?

```{r indirHDPI, message=FALSE, warning=FALSE}
# calculate whether true value is in HPDI

recaptured_indir <- which_params_recaptured(params_indir)
prop_recaptured_indir <- calc_prop_recaptured_overall(recaptured_indir, truepars=parframe_indir)
prop_recaptured_by_param_indir <- calc_recaptured_by_param(recaptured_indir, parframe_indir) 

```

```{r plotIndirRecaptureoverall}
ggplot(prop_recaptured_indir$fifty, aes(x=as.factor(anchor), y=as.factor(beta_rate), fill=mean_captured)) + 
  geom_tile(colour="white") +
  geom_text(aes(label=modelid)) +
  facet_wrap("transition", scales="free") +
  ggtitle("Proportion of parameters recaptured in 50% HPDI", subtitle = "faceted by transition speed in simulated dataset") +
  scale_fill_viridis_c(limits=c(0,5)) +
  ylab("beta_rate")

ggplot(prop_recaptured_indir$ninety, aes(x=as.factor(anchor), y=as.factor(beta_rate), fill=mean_captured)) + 
  geom_tile(colour="white") +
  geom_text(aes(label=modelid)) +
  facet_wrap("transition", scales="free") +
  ggtitle("Proportion of parameters recaptured in 90% HPDI",subtitle = "faceted by transition speed in simulated dataset") +
  scale_fill_viridis_c(limits=c(0,5)) +
  ylab("beta_rate")
```

Using an induced dirichlet prior on the cutpoints doesn't seem to work very well.

Which parameters are easier or harder to recapture?

```{r plotIndirRecapture}
#knitr::kable(perform50, caption = "Ability of the different models to recapture parameters in 50% HPDI. Each model only run only once.")
#
# proportion of the time each parameter is returned correctly

# perform50_summary <- perform50 %>%
#   group_by(modelid, anchor, beta_rate, beta, param, transition) %>%
#   summarise(prop_inint = mean(inint))
# 
# perform90_summary <- perform90 %>%
#   group_by(modelid, anchor, beta_rate, beta, param, transition) %>%
#   summarise(prop_inint = mean(inint))
#   



ggplot(prop_recaptured_by_param$fifty, aes(x=param, y=as.factor(modelid), fill=prop_inint)) + 
  geom_tile(color="black") +
  scale_fill_viridis_c()  +
  geom_text(aes(label=paste(anchor, beta_rate, sep="\n")), size=2.5) +
  facet_wrap("transition", scales="free") +
  ggtitle("Parameters recaptured in 50% HPDI", subtitle = "faceted by transition speed (beta) in simulated dataset\n with anchor and beta rate labels") +
  theme(legend.position = "top") +
  ylab("model id")

ggplot(perform90_summary, aes(x=param, y=as.factor(modelid), fill=prop_inint)) + 
  geom_tile(color="black") +
  scale_fill_viridis_c()  +
  geom_text(aes(label=paste(anchor, beta_rate, sep="\n")), size=2.5) +
  facet_wrap("transition", scales="free") +
  ggtitle("Parameters recaptured in 90% HPDI", subtitle = "faceted by transition speed (beta) in simulated dataset\n with anchor and beta rate labels") +
  theme(legend.position = "top") +
  ylab("model id")

```
When transitions are fast, no anchor allows $\beta$ and $c$ to be recaptured, but half transition points $h$ are (but $h_2$ isn't ever captured in 50% HPDI, only 90%). 

When transitions are medium speed, a large anchor allows all parameters to be recaptured in the 90% HPDI. Any anchor allows $h$ to be recaptured in the 90%, but $h_2$, again, is never captured in the 50%.

When transitions are slow, $h2$ is never recaptured, but all other parameters are recaptured in the 90% HPDI. $\beta$ is recaptured better when anchors are lower, $c_1$ is captured better when anchor is 5, and $h_1$ is captured better when anchors are large (10).

## Best prior parameter choices

```{r plotGammaParams, fig.height=3, fig.width=4}

map(params_indir[base::sample(1:30, 5)], parplot) # pick 5 models at random to plot

```
