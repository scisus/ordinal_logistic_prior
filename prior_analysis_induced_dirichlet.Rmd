---
title: "Gamma priors on cutpoints in an ordinal logistic model"
author: "Susannah Tysor"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r packages}
library(purrr)
library(dplyr)
library(ggplot2)
library(bayesplot)
library(rstan)
```
```{r options}
rstan_options(auto_write=TRUE)
```
```{r depends}
source('priorAnalysisGammaFunctions.R')
source('prior_analysis_functions.R')
```

```{r simulate_data}

simulation_input <- set_simulation_parameters()

simdat <- map(simulation_input$inputlist, simulate_data, groups=FALSE)

plot_simulated_data(simdat, simulation_input$inputlist)
```
```{r set_dirichlet_priors}

beta_rate <- c(1:3) # rate parameters for exponential prior on beta
anchor <- c(0, 5, 10) # different anchor parameters for induced dirichlet prior

# make a nice dataframe with all combinations params used to simulate data and model params used to try to recover those params

parframe_indir <- merge(simulation_input$pars, y=beta_rate) %>%
    rename(beta_rate=y) %>%
    merge(y=anchor) %>%
    rename(anchor=y) %>%
    mutate(h1 = simulation_input$h[1], h2 = simulation_input$h[2])
parframe_indir$modelid <- 1:nrow(parframe_indir)
    
```

```{r recapture_parameters}
# format parframe so it works with parLapply better
parlist_indir <- make_parframe_list(parframe_indir)

# run all models, parallelized

# make a cluster using half your cores
no_cores <- parallel::detectCores()/2
cl <- parallel::makeCluster(no_cores)

# export the stuff you need to run on the cluster
parallel::clusterExport(cl, c("fit_indir_model", "parlist_indir", "simdat"))
parallel::clusterEvalQ(cl, c(library(rstan), library(StanHeaders)))

indirfits <- parallel::parLapply(cl, parlist_indir, function(x) {fit_indir_model(simdatlist = simdat, pars=x, groups=FALSE)})

parallel::stopCluster(cl) #close the cluster

```
```{r}
indir_params <- bind_true_model_pars(indirfits, parlist_indir)
```
```{r modelcheck}
map(indirfits, function(x) {rstan:::throw_sampler_warnings(x)})
```

```{r}
map(indir_params, posterior_differencer) %>%
    map2(.y=indir_params, .f=diffplotter)
```

```{r induced_dirichlet_hpdi}
in50 <- map(indir_params, calc_HPDI, prob=0.5)

in75 <- map(indir_params, calc_HPDI, prob=0.75)

in90 <- map(indir_params, calc_HPDI, prob=0.90)

# recaptured parameters
perform50 <- map_df(in50, bind_rows, .id="modelid") %>%
  dplyr::mutate(modelid=as.integer(modelid)) %>%
  full_join(parframe_indir) 
perform90 <- map_df(in90, bind_rows, .id = "modelid") %>%
  dplyr::mutate(modelid=as.integer(modelid)) %>%
  full_join(parframe_indir)

# proportion recaptured parameters
prop_recaptured50 <- perform50 %>%
  group_by(modelid) %>%
  summarise(all_captured = sum(inint)/n()) %>%
  full_join(parframe_indir) %>%
  arrange(beta, desc(all_captured))

prop_recaptured90 <- perform90 %>%
  group_by(modelid) %>%
  summarise(all_captured = sum(inint)/n()) %>%
  full_join(parframe_indir) %>%
  arrange(beta, desc(all_captured))
```

```{r plot_dirichlet_overall}
ggplot(prop_recaptured50, aes(x=as.factor(anchor), y=as.factor(beta_rate), fill=all_captured)) + 
  geom_tile(colour="white") +
  geom_text(aes(label=paste(anchor, beta_rate, sep=","))) +
  facet_wrap("transition", scales="free") +
  ggtitle("Proportion of parameters recaptured in 50% HPDI") +
  scale_fill_gradient(low="white", high="steelblue")

ggplot(prop_recaptured90, aes(x=as.factor(anchor), y=as.factor(beta_rate), fill=all_captured)) + 
  geom_tile(colour="white") +
  geom_text(aes(label=paste(anchor, beta_rate, sep=","))) +
  facet_wrap("transition", scales="free") +
  ggtitle("Proportion of parameters recaptured in 90% HPDI") +
  scale_fill_gradient(low="white", high="violetred")
```
With a normally distributed covariate, the induced dirichlet really struggles, but is good with uniform. Reducing data points from 500 to 50 reduces quality. Also a weird thing keeps happening where 50% seems to do better in some cases than 90% hpdi, but might be a colour scaling issue.
